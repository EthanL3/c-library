# Code Overview
For this project, I created my shell using the scaffold provided in one of the slides from the lectures. In this code structure, the shell runs in an infinite while loop, prompting the user for an input each time. Once the user inputs their command(s), a fork is created and in the child process, execvp() is called using the user's inputs. The user-input is parsed inside a separate function read_commands(). Then, the first command from their input is individually parsed using parse_args().
## read_commands():
This function parses the entire user inputted string by splitting the input string on the pipe command (|). It returns an int representing how many commands in the pipeline were parse (1 if no pipes). It stores a pointer to each command string in the commands[] array.
## parse_args():
This function parses the individual commands (not the entire user input), which were stored inside commands[]. It splits the command string on these delimiters: " ", "\t", "\n", and "\"". It stores the splitted string inside args, an array created inside this function. This array is dynamically allocated using malloc() since we want its value to persist after the function terminates, as main() ends up calling this function and using its return value. 
## main():
Inside main, I prompt the user to type in their inputs inside an infinite while loop. Once the user enters their input, it gets passed to read_commands, and then if they entered more than one command via a pipe, I construct a pipeline 2d array and use the hint #5 in the homework1.pdf to redirect input and outputs as needed. Additionally, I check for any input redirection for this first command in the pipeline and output redirection in the last command. The trim_spacing function is called here to get rid of any leading or trailing whitespace for the commands themselves and for any file names. After redirecting input and output to files (if needed) the ith command in the pipeline is executed via execvp(). The ith command itself is parsed using parse_args before passing it to execvp(). 
If the user entered just one command (no pipes), then that single command is checked for any file redirection (input, output, or both), and then parsed using parse_args(), and then execvp() executes it. Unlike the pipeline commands, a singular command may have its input and output redirected to files, hence the additional if statement checking for this. The file input/output redirection for all cases is done using the steps described in hint #5.
## Background Processes:
In the event the user enters a '&' at the end of their input, this is interpreted by read_commands and a flag is set indicating that this is a background process. Inside main(), the parent process after forking checks if this flag (background_process) is false. If is it false, then the parent will wait for the child, otherwise it will not call wait and immediately print the prompt again. To collect all the exit codes of the children processes (to avoid zombies), I set up my own signal handler for sigchild (collect_sigchild). This function uses an infinte while loop that calls waitpid() for all child processes (pid > 0). This reaps any child processes which were running in the background and finished and stores their exit status inside the status variable.
## Challenges Faced:
The main problem I faced when completing the shell was figuring out how to break apart the initial user input. I first thought I should split the string based on any of the redirection characters (|, <, >), but I soon realized this made it much harder to properly interpret seperate commands. I then realized the easiest way is to just split the string based on the pipe command then handle file redirection seperately. 

## Sources:
Here are a list of sources I used when completing this project:  
1. https://www.cs.colby.edu/maxwell/courses/tutorials/maketutor/ - help for creating the makefile
3. https://www.geeksforgeeks.org/strtok-strtok_r-functions-c-examples/ - guide for how to use strtok() in C