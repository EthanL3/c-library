# Thread Synchronization:
In this project, I extended the threading library impelmentation done in project2. Specically, I added the lock and unlock functions, pthread_join, and the semaphore functions. In order to incorporate the pthread_join function, I had to add an exit_value field to my tcb, which is a pointer that stores the value_ptr passed into pthread_exit. In pthread_join, *value_ptr is set to exit_value of the target thread. I also had to add a 'waiting_on' field to my tcb, which keeps track of the thread (if there is one) that is 'waiting on' (BLOCKED by) this thread. For my sempahore functions, I used the structure described in class by the professor, with a queue of waiting threads. In sem_post, if the value of the semaphore is greater than 0, then the next thread in the queue gets set to READY and is allowed to schedule. After that, the entire queue of waiting threads get shifted down 1 spot (so the thread at index 1 goes 0, thread at index 2 goes to 1, and so on).
## Challenges I Faced:
The main problem I faced was getting caught an infinite while loop in schedule. This would happen after pthread_join gets called for the final time. The target thread had already been exited and the current_thread was BLOCKED, meaning when schedule got called there was only one thread (current) that was not exited, but it was blocked, so it would never schedule and the while loop ran forever. The way I resolved this was adding the waiting_on field in my tcb. This allowed me to keep track of the thread that was blocked by the target thread. I then changed pthread_exit to check if any thread had been blocked by this thread. If so, then that thread's status gets set from BLOCKED to READY, so the next time the scheduler ran, it was possible for that thread to be run.